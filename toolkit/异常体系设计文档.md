# 异常体系设计文档

## 📋 概述

本文档详细介绍了 toolkit 模块中异常体系的设计思路、架构组成、使用方法和最佳实践。该异常体系支持国际化，采用简化设计，只区分业务异常和系统异常，提供了统一的异常处理机制。

## 🏗️ 架构设计

### 1. 异常体系层次结构（简化版）

```
RuntimeException
    └── BaseException (基础异常类)
        ├── BusinessException (业务异常 - 包含验证、认证等所有业务相关异常)
        └── SystemException (系统异常 - 数据库、网络等系统级异常)
```

### 2. 异常码体系

```
ExceptionCode (基础异常码接口)
    └── I18nExceptionCode (国际化异常码接口)
        ├── CommonExceptionCode (通用异常码枚举)
        └── I18nCommonExceptionCode (国际化通用异常码枚举)
```

### 3. 核心组件

- **BaseException**: 所有业务异常的基类
- **BusinessException**: 业务异常（包含验证、认证等）
- **SystemException**: 系统异常（数据库、网络等）
- **I18nExceptionCode**: 支持国际化的异常码接口
- **I18nMessageService**: 国际化消息服务
- **ExceptionUtils**: 异常工具类
- **Assert**: 断言工具类
- **GlobalExceptionHandler**: 全局异常处理器

## 🎯 设计原则

### 1. 简化优先
- **只区分业务异常和系统异常** - Auth、Validation 等都归类为业务异常
- **避免过度分类** - 减少开发者的选择困难，提高开发效率
- **统一的异常处理机制** - 简化异常处理逻辑

### 2. 国际化支持
- 支持多语言异常消息
- 参数化消息模板
- 自动语言环境检测

### 3. 实用性设计
- **Assert** - 提供断言风格的验证方法
- **ExceptionUtils** - 提供便捷的异常创建和抛出方法
- 按错误码分类（4xx客户端错误、5xx服务端错误、1xxx业务错误等）

### 4. 易用性
- 语义清晰的方法命名
- 支持多种调用方式
- 丰富的工具方法

## 📊 异常码规范

### 错误码分类

| 范围 | 类型 | 说明 | 示例 |
|------|------|------|------|
| 0 | 成功 | 操作成功 | 0 |
| 4xx | 客户端错误 | HTTP标准错误码 | 400, 401, 403, 404 |
| 5xx | 服务端错误 | HTTP标准错误码 | 500, 501, 503 |
| 1000-1099 | 通用业务错误 | 基础业务异常 | 1000, 1001, 1002 |
| 1100-1199 | 参数验证错误 | 参数格式、范围等 | 1100, 1101, 1102 |
| 1200-1299 | 用户相关错误 | 用户操作相关 | 1200, 1201, 1202 |
| 2000-2999 | 数据库错误 | 数据库操作异常 | 2000, 2001, 2002 |
| 3000-3999 | 外部服务错误 | 第三方服务调用 | 3000, 3001, 3002 |
| 4000-4999 | 文件操作错误 | 文件上传下载等 | 4000, 4001, 4002 |

### 异常码命名规范

```java
// 格式：[模块]_[操作]_[结果]
USER_LOGIN_FAILED("1203", "exception.user_login_failed", "用户登录失败"),
FILE_UPLOAD_SIZE_EXCEEDED("4003", "exception.file_upload_size_exceeded", "文件大小超出限制 {0}MB");
```

## 🚀 使用指南

### 1. 基础使用

#### 抛出异常

```java
// 使用异常工具类
ExceptionUtils.throwBusiness(I18nCommonExceptionCode.DATA_NOT_FOUND);

// 带参数的异常
ExceptionUtils.throwValidation(I18nCommonExceptionCode.PARAM_REQUIRED, "username");

// 条件异常
ExceptionUtils.throwBusinessIf(user == null, I18nCommonExceptionCode.USER_NOT_FOUND);
```

#### 创建异常

```java
// 创建但不抛出
BusinessException exception = ExceptionUtils.business(I18nCommonExceptionCode.DATA_ALREADY_EXISTS);

// 带原因的系统异常
SystemException sysException = ExceptionUtils.system(I18nCommonExceptionCode.DATABASE_ERROR, cause);
```

### 2. 参数验证

```java
public void createUser(CreateUserRequest request) {
    // 验证必填参数
    ExceptionUtils.requireNonNull(request, "request");
    ExceptionUtils.requireNonBlank(request.getUsername(), "username");
    ExceptionUtils.requireNonBlank(request.getEmail(), "email");
    
    // 验证业务规则
    ExceptionUtils.requireTrue(isValidEmail(request.getEmail()), 
                              I18nCommonExceptionCode.EMAIL_INVALID);
    
    // 验证用户不存在
    ExceptionUtils.throwBusinessIf(userExists(request.getUsername()), 
                                  I18nCommonExceptionCode.USER_ALREADY_EXISTS);
}
```

### 3. 自定义异常码

```java
public enum UserExceptionCode implements I18nExceptionCode {
    USER_LOGIN_FAILED("1203", "exception.user_login_failed", "用户登录失败"),
    USER_ACCOUNT_LOCKED("1204", "exception.user_account_locked", "用户账户已锁定"),
    USER_PASSWORD_WEAK("1205", "exception.user_password_weak", "密码强度不足");
    
    private final String code;
    private final String messageKey;
    private final String desc;
    
    // 构造函数和getter方法...
}
```

### 4. 国际化配置

#### Spring Boot 配置

```java
@Configuration
public class I18nConfig {
    
    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasename("messages");
        messageSource.setDefaultEncoding("UTF-8");
        messageSource.setCacheSeconds(3600);
        return messageSource;
    }
    
    @Bean
    public LocaleResolver localeResolver() {
        AcceptHeaderLocaleResolver resolver = new AcceptHeaderLocaleResolver();
        resolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);
        return resolver;
    }
}
```

#### 资源文件结构

```
src/main/resources/
├── messages.properties              # 默认语言（英文）
├── messages_zh_CN.properties       # 简体中文
├── messages_zh_TW.properties       # 繁体中文
├── messages_en_US.properties       # 美式英文
└── messages_ja_JP.properties       # 日文
```

### 5. 全局异常处理

全局异常处理器会自动处理所有异常，并返回统一格式的响应：

```json
{
  "code": 1001,
  "message": "数据不存在",
  "data": null
}
```

## 🌍 国际化支持

### 1. 消息模板

支持参数化消息模板：

```properties
# 英文
exception.param_out_of_range=Parameter {0} is out of range [{1}, {2}]
exception.file_size_exceeded=File size exceeds limit {0}MB

# 中文
exception.param_out_of_range=参数 {0} 超出范围 [{1}, {2}]
exception.file_size_exceeded=文件大小超出限制 {0}MB
```

### 2. 使用示例

```java
// 抛出带参数的异常
ExceptionUtils.throwValidation(
    I18nCommonExceptionCode.PARAM_OUT_OF_RANGE, 
    "age", "18", "65"
);

// 根据当前语言环境，会显示：
// 英文：Parameter age is out of range [18, 65]
// 中文：参数 age 超出范围 [18, 65]
```

### 3. 语言环境检测

```java
@Autowired
private I18nMessageService messageService;

public void someMethod() {
    if (messageService.isChinese()) {
        // 中文环境特殊处理
    } else if (messageService.isEnglish()) {
        // 英文环境特殊处理
    }
}
```

## 📝 最佳实践

### 1. 异常分类原则

- **BusinessException**: 业务逻辑异常，用户可理解的错误
- **ValidationException**: 参数验证异常，输入数据格式错误
- **SystemException**: 系统级异常，如数据库连接失败
- **AuthException**: 认证授权异常，权限相关错误

### 2. 异常消息设计

```java
// ✅ 好的做法：消息清晰，用户友好
USER_NOT_FOUND("1200", "exception.user_not_found", "用户不存在")

// ❌ 避免：技术细节暴露
DATABASE_CONNECTION_FAILED("2000", "exception.db_error", "Connection refused: localhost:3306")
```

### 3. 异常处理层次

```java
@Service
public class UserService {
    
    public User getUserById(Long id) {
        // 参数验证
        ExceptionUtils.requireNonNull(id, "id");
        
        try {
            User user = userRepository.findById(id);
            
            // 业务验证
            ExceptionUtils.throwBusinessIf(user == null, I18nCommonExceptionCode.USER_NOT_FOUND);
            
            return user;
        } catch (DataAccessException e) {
            // 系统异常
            throw ExceptionUtils.system(I18nCommonExceptionCode.DATABASE_ERROR, e);
        }
    }
}
```

### 4. 日志记录

```java
@ExceptionHandler(BusinessException.class)
public ResponseEntity<Response<Void>> handleBusinessException(BusinessException e) {
    // 业务异常记录为 WARN 级别
    log.warn("Business exception: code={}, message={}", e.getCode(), e.getMessage());
    
    return ResponseEntity.ok(buildErrorResponse(e));
}

@ExceptionHandler(SystemException.class)
public ResponseEntity<Response<Void>> handleSystemException(SystemException e) {
    // 系统异常记录为 ERROR 级别，包含堆栈信息
    log.error("System exception: code={}, message={}", e.getCode(), e.getMessage(), e);
    
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(buildErrorResponse(e));
}
```

### 5. 性能考虑

- 异常创建有性能开销，避免在正常业务流程中使用异常控制逻辑
- 国际化消息服务支持缓存，避免重复解析
- 合理使用异常链，保留原始异常信息

## 🔧 扩展指南

### 1. 添加新的异常类型

```java
public class IntegrationException extends BaseException {
    public IntegrationException(ExceptionCode exceptionCode) {
        super(exceptionCode);
    }
    
    // 其他构造函数...
}
```

### 2. 添加新的异常码

```java
public enum IntegrationExceptionCode implements I18nExceptionCode {
    THIRD_PARTY_API_ERROR("3100", "exception.third_party_api_error", "第三方API调用失败"),
    DATA_SYNC_FAILED("3101", "exception.data_sync_failed", "数据同步失败");
    
    // 实现接口方法...
}
```

### 3. 自定义异常处理器

```java
@ExceptionHandler(IntegrationException.class)
public ResponseEntity<Response<Void>> handleIntegrationException(IntegrationException e) {
    // 自定义处理逻辑
    log.error("Integration exception: {}", e.getMessage(), e);
    
    // 可以发送告警、记录监控指标等
    alertService.sendAlert("Integration Error", e.getMessage());
    
    return ResponseEntity.status(HttpStatus.BAD_GATEWAY).body(buildErrorResponse(e));
}
```

## 📚 总结

该异常体系提供了：

1. **完整的异常分类** - 覆盖业务、验证、系统、认证等各种场景
2. **国际化支持** - 支持多语言异常消息，参数化模板
3. **统一的处理机制** - 全局异常处理器，统一响应格式
4. **便捷的工具方法** - 简化异常创建和抛出操作
5. **良好的扩展性** - 易于添加新的异常类型和异常码
6. **最佳实践指导** - 提供完整的使用指南和最佳实践

通过使用这套异常体系，可以大大提高代码的健壮性、可维护性和用户体验。