# 企业应用开发最佳实践指南

## 📋 概述

本文档总结了使用toolkit模块进行企业应用开发的最佳实践，涵盖架构设计、编码规范、性能优化、安全实践等方面的经验和建议。

## 🏗️ 架构设计最佳实践

### 1. 分层架构原则

```
Controller 层 (表现层)
├── 参数验证
├── 权限检查  
├── 异常处理
└── 响应封装

Service 层 (业务层)
├── 业务逻辑
├── 事务管理
├── 业务验证
└── 数据转换

Repository 层 (数据层)
├── 数据访问
├── 查询优化
└── 数据一致性
```

### 2. 统一响应格式

```java
// 统一使用Response包装响应
@RestController
public class UserController {
    
    @GetMapping("/users/{id}")
    public Response<UserDTO> getUser(@PathVariable Long id) {
        UserDTO user = userService.getUser(id);
        return Response.success(user);
    }
    
    @PostMapping("/users/query")
    public Response<Pagination<UserDTO>> queryUsers(@RequestBody UserQuery query) {
        Pagination<UserDTO> result = userService.queryUsers(query);
        return Response.success(result);
    }
}
```

### 3. 异常处理规范

```java
// Service层使用断言和异常工具
@Service
public class UserService {
    
    public UserDTO getUser(Long id) {
        // 参数验证
        ExceptionUtils.requireNonNull(id, "用户ID不能为空");
        
        // 业务逻辑
        User user = userRepository.findById(id);
        ExceptionUtils.throwBusinessIf(user == null, 
                I18nCommonExceptionCode.DATA_NOT_FOUND);
        
        return userConverter.toDTO(user);
    }
}
```

## 💻 编码规范最佳实践

### 1. 类和方法设计

```java
// 单一职责原则
@Service
public class UserService {
    
    // 方法功能单一、职责明确
    public UserDTO createUser(UserCreateRequest request) {
        validateUserRequest(request);
        User user = buildUserFromRequest(request);
        User savedUser = saveUser(user);
        publishUserCreatedEvent(savedUser);
        return userConverter.toDTO(savedUser);
    }
    
    private void validateUserRequest(UserCreateRequest request) {
        // 验证逻辑
    }
    
    private User buildUserFromRequest(UserCreateRequest request) {
        // 构建逻辑
    }
}
```

### 2. 参数验证规范

```java
// 分层验证：Controller基础验证 + Service业务验证
@RestController
public class UserController {
    
    @PostMapping("/users")
    public Response<UserDTO> createUser(@Valid @RequestBody UserCreateRequest request) {
        // Controller层只做基础验证，业务验证在Service层
        UserDTO user = userService.createUser(request);
        return Response.success(user);
    }
}

@Service
public class UserService {
    
    public UserDTO createUser(UserCreateRequest request) {
        // Service层做业务验证
        ExceptionUtils.requireNonNull(request, "请求不能为空");
        ExceptionUtils.throwBusinessIf(
                userRepository.existsByUsername(request.getUsername()),
                I18nCommonExceptionCode.USER_ALREADY_EXISTS
        );
        // 业务逻辑...
    }
}
```

### 3. 数据转换规范

```java
// 使用MapStruct进行对象转换
@Mapper(componentModel = "spring")
public interface UserConverter {
    
    UserDTO toDTO(User user);
    
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createTime", ignore = true)
    User toEntity(UserCreateRequest request);
    
    List<UserDTO> toDTOList(List<User> users);
}
```

## 🚀 性能优化最佳实践

### 1. 数据库查询优化

```java
// 使用分页查询避免大数据量查询
@Service
public class UserService {
    
    public Pagination<UserDTO> queryUsers(UserQuery query) {
        // 构建查询条件
        QueryWrapper<User> wrapper = buildQueryWrapper(query);
        
        // 分页查询
        Page<User> page = new Page<>(query.getPageNum(), query.getPageSize());
        Page<User> result = userRepository.selectPage(page, wrapper);
        
        // 转换为DTO
        List<UserDTO> userDTOs = userConverter.toDTOList(result.getRecords());
        
        return Pagination.of(userDTOs, result.getTotal(), 
                query.getPageNum(), query.getPageSize());
    }
}
```

### 2. 缓存使用规范

```java
// 合理使用缓存
@Service
public class UserService {
    
    @Cacheable(value = "users", key = "#id")
    public UserDTO getUser(Long id) {
        User user = userRepository.findById(id);
        ExceptionUtils.throwBusinessIf(user == null, 
                I18nCommonExceptionCode.DATA_NOT_FOUND);
        return userConverter.toDTO(user);
    }
    
    @CacheEvict(value = "users", key = "#user.id")
    public UserDTO updateUser(UserUpdateRequest request) {
        // 更新逻辑
    }
}
```

### 3. 异步处理

```java
// 耗时操作使用异步处理
@Service
public class NotificationService {
    
    @Async
    public CompletableFuture<Void> sendNotificationAsync(Long userId, String message) {
        // 异步发送通知
        try {
            sendNotification(userId, message);
            return CompletableFuture.completedFuture(null);
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }
}
```

## 🔒 安全实践最佳实践

### 1. 输入验证

```java
// 严格的输入验证
@RestController
public class UserController {
    
    @PostMapping("/users")
    public Response<UserDTO> createUser(@Valid @RequestBody UserCreateRequest request) {
        // 1. 基础验证（Bean Validation）
        // 2. 业务验证在Service层
        // 3. SQL注入防护（使用MyBatis参数化查询）
        // 4. XSS防护（输出时转义）
        
        UserDTO user = userService.createUser(request);
        return Response.success(user);
    }
}
```

### 2. 权限控制

```java
// 多层权限控制
@RestController
@RequestMapping("/api/admin")
@PreAuthorize("hasRole('ADMIN')")  // 全局权限
public class AdminController {
    
    @GetMapping("/users/{id}")
    @PreAuthorize("hasPermission(#id, 'USER', 'READ')")  // 资源权限
    public Response<UserDTO> getUser(@PathVariable Long id) {
        UserDTO user = userService.getUser(id);
        return Response.success(user);
    }
}
```

### 3. 敏感数据处理

```java
// 敏感数据加密和脱敏
@Entity
public class User {
    
    @Column(name = "password")
    @Convert(converter = PasswordConverter.class)  // 密码加密存储
    private String password;
    
    @Column(name = "mobile") 
    @Convert(converter = MobileConverter.class)    // 手机号加密存储
    private String mobile;
    
    // DTO中敏感字段脱敏
    @JsonSerialize(using = SensitiveDataSerializer.class)
    public String getMobile() {
        return mobile;
    }
}
```

## 📊 监控和日志最佳实践

### 1. 操作日志

```java
// 关键操作记录审计日志
@Service
public class UserService {
    
    @Auditable(operation = "CREATE_USER")
    public UserDTO createUser(UserCreateRequest request) {
        try {
            User user = userConverter.toEntity(request);
            User savedUser = userRepository.save(user);
            
            log.info("用户创建成功 - 用户ID: {}, 用户名: {}", 
                    savedUser.getId(), savedUser.getUsername());
            
            return userConverter.toDTO(savedUser);
        } catch (Exception e) {
            log.error("用户创建失败 - 用户名: {}, 错误: {}", 
                    request.getUsername(), e.getMessage(), e);
            throw e;
        }
    }
}
```

### 2. 性能监控

```java
// 关键接口性能监控
@RestController
public class UserController {
    
    @Timed(name = "user.query", description = "用户查询接口耗时")
    @GetMapping("/users/query")
    public Response<Pagination<UserDTO>> queryUsers(@RequestBody UserQuery query) {
        Pagination<UserDTO> result = userService.queryUsers(query);
        return Response.success(result);
    }
}
```

## 🧪 测试最佳实践

### 1. 单元测试

```java
// 全面的单元测试
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private UserConverter userConverter;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    void createUser_Success() {
        // given
        UserCreateRequest request = buildUserCreateRequest();
        User user = buildUser();
        UserDTO expectedDTO = buildUserDTO();
        
        when(userRepository.existsByUsername(request.getUsername())).thenReturn(false);
        when(userConverter.toEntity(request)).thenReturn(user);
        when(userRepository.save(user)).thenReturn(user);
        when(userConverter.toDTO(user)).thenReturn(expectedDTO);
        
        // when
        UserDTO result = userService.createUser(request);
        
        // then
        assertThat(result).isEqualTo(expectedDTO);
        verify(userRepository).save(user);
    }
    
    @Test
    void createUser_ThrowsException_WhenUsernameExists() {
        // given
        UserCreateRequest request = buildUserCreateRequest();
        when(userRepository.existsByUsername(request.getUsername())).thenReturn(true);
        
        // when & then
        assertThatThrownBy(() -> userService.createUser(request))
                .isInstanceOf(BusinessException.class)
                .hasMessageContaining("用户名已存在");
    }
}
```

### 2. 集成测试

```java
// 关键功能集成测试
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Transactional
class UserControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    void createUser_Success() throws Exception {
        // given
        UserCreateRequest request = buildUserCreateRequest();
        
        // when & then
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value(0))
                .andExpect(jsonPath("$.data.username").value(request.getUsername()));
    }
}
```

## 📦 部署和运维最佳实践

### 1. 配置管理

```yaml
# application.yml - 环境相关配置
spring:
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}
  datasource:
    url: ${DB_URL:jdbc:mysql://localhost:3306/toolkit}
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:password}

# 敏感配置使用环境变量
app:
  jwt:
    secret-key: ${JWT_SECRET_KEY}
    token-validity-in-seconds: ${JWT_TOKEN_VALIDITY:3600}
```

### 2. 健康检查

```java
// 自定义健康检查
@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public Health health() {
        try (Connection connection = dataSource.getConnection()) {
            if (connection.isValid(1)) {
                return Health.up()
                        .withDetail("database", "Available")
                        .build();
            }
        } catch (Exception e) {
            return Health.down()
                    .withDetail("database", "Unavailable")
                    .withException(e)
                    .build();
        }
        return Health.down().build();
    }
}
```

## 📚 总结

遵循以上最佳实践可以：

1. **提高代码质量** - 规范的编码风格和设计模式
2. **增强系统安全** - 多层安全防护和数据保护
3. **优化系统性能** - 合理的缓存和异步处理
4. **便于维护** - 清晰的架构分层和异常处理
5. **确保可靠性** - 完善的测试和监控体系

记住：最佳实践不是教条，要根据具体项目需求灵活应用，在代码质量、性能和开发效率之间找到最佳平衡点。