# 异常体系快速上手指南

## 🏆 KISS原则优化！

我们按照 **Keep It Simple and Stupid** 原则对异常体系进行了全面优化：

✨ **自动国际化**: `ExceptionHandlerResult.system(exceptionCode)` 自动处理国际化消息  
✨ **一行代码**: 无需手动调用 `ExceptionUtils.getLocalizedMessage()`  
✨ **统一体验**: 所有异常策略都使用相同的简化API  
✨ **快速上手**: 新手也能在几分钟内掌握  

---

## 🚀 5分钟快速上手

### 第一步：理解两种异常类型

```java
// 业务异常 - 用户操作导致，可预期
BusinessException → 用户看得懂的错误（如：用户不存在）

// 系统异常 - 技术问题，不可预期  
SystemException → 技术问题（如：数据库连接失败）
```

### 第二步：掌握异常抛出方式

#### 方式一：直接抛出（推荐）
```java
// 业务异常
ExceptionUtils.throwBusiness(I18nCommonExceptionCode.USER_NOT_FOUND);
ExceptionUtils.throwBusiness(I18nCommonExceptionCode.DATA_ALREADY_EXISTS, "用户名");

// 系统异常
ExceptionUtils.throwSystem(I18nCommonExceptionCode.DATABASE_ERROR);
ExceptionUtils.throwSystem(I18nCommonExceptionCode.NETWORK_ERROR, cause);
```

#### 方式二：条件判断
```java
// 条件异常
ExceptionUtils.throwIf(user == null, I18nCommonExceptionCode.USER_NOT_FOUND);
ExceptionUtils.throwIf(email.exists(), I18nCommonExceptionCode.USER_ALREADY_EXISTS);

// 系统条件异常
ExceptionUtils.throwSystemIf(connection == null, I18nCommonExceptionCode.DATABASE_ERROR);
```

#### 方式三：断言方式（最简洁）
```java
// 参数验证
Assert.notNull(request, "request");
Assert.notBlank(username, "username");
Assert.validEmail(email);

// 业务断言
Assert.exists(user);           // 等同于 throwIf(user == null, DATA_NOT_FOUND)
Assert.hasPermission(canAccess);
Assert.authenticated(isLoggedIn);
```

### 第三步：了解响应格式
所有异常都会被转换为统一的JSON格式：
```json
{
  "code": 1001,
  "message": "用户不存在",
  "data": null
}
```

**国际化支持**：
- 所有错误消息都支持国际化
- 系统会根据请求头的Accept-Language自动选择语言
- 支持参数化消息模板，如："参数 {0} 超出范围 [{1}, {2}]"

例如，同一个错误在不同语言环境下的显示：
```json
// 中文环境
{ "code": 1001, "message": "用户不存在" }

// 英文环境  
{ "code": 1001, "message": "User not found" }
```

### 第四步：查看调试信息
每个异常都会生成traceId，便于日志关联：
```
异常处理 [abc123def456] - 路径: /api/users, 错误码: 1001, 消息: 用户不存在
```

## 📚 常用场景示例

### 用户管理场景
```java
@Service
public class UserService {
    
    public User getUserById(Long id) {
        // 参数验证
        Assert.notNull(id, "id");
        
        User user = userRepository.findById(id);
        
        // 业务验证
        Assert.exists(user);  // 用户不存在时自动抛出异常
        
        return user;
    }
    
    public void createUser(CreateUserRequest request) {
        // 参数验证
        Assert.notNull(request, "request");
        Assert.notBlank(request.getUsername(), "username");
        Assert.validEmail(request.getEmail());
        
        // 业务验证
        boolean userExists = userRepository.existsByUsername(request.getUsername());
        ExceptionUtils.throwIf(userExists, I18nCommonExceptionCode.USER_ALREADY_EXISTS);
        
        // 创建用户...
    }
    
    public void deleteUser(Long id, User currentUser) {
        User user = getUserById(id);  // 复用上面的方法
        
        // 权限检查
        Assert.hasPermission(canDeleteUser(currentUser, user));
        
        userRepository.delete(user);
    }
}
```

### 安全认证场景
```java
@Service
public class AuthService {
    
    public LoginResult login(String username, String password) {
        // 参数验证
        Assert.notBlank(username, "username");
        Assert.notBlank(password, "password");
        
        User user = userRepository.findByUsername(username);
        Assert.exists(user);  // 用户不存在
        
        // 账户状态检查
        Assert.accountEnabled(!user.isDisabled());
        Assert.accountNotLocked(user.isLocked());
        
        // 密码验证
        Assert.correctPassword(passwordEncoder.matches(password, user.getPassword()));
        
        // 生成Token...
        return new LoginResult(token);
    }
    
    public void checkPermission(String resource, User user) {
        Assert.authenticated(user != null);
        
        boolean hasPermission = permissionService.hasPermission(user, resource);
        Assert.hasPermissionFor(hasPermission, resource);
    }
}
```

### 数据操作场景
```java
@Service
public class OrderService {
    
    public void cancelOrder(Long orderId, User user) {
        Assert.notNull(orderId, "orderId");
        Assert.authenticated(user != null);
        
        Order order = orderRepository.findById(orderId);
        Assert.exists(order);
        
        // 业务规则验证
        ExceptionUtils.throwIf(!order.getOwner().equals(user), 
                              I18nCommonExceptionCode.PERMISSION_DENIED);
        
        ExceptionUtils.throwIf(order.getStatus() != OrderStatus.PENDING,
                              I18nCommonExceptionCode.OPERATION_NOT_ALLOWED, "订单状态不允许取消");
        
        order.setStatus(OrderStatus.CANCELLED);
        orderRepository.save(order);
    }
}
```

## 🛠️ 进阶使用

### 添加自定义异常码
```java
public enum OrderExceptionCode implements I18nExceptionCode {
    ORDER_NOT_FOUND("2001", "exception.order_not_found", "订单不存在"),
    ORDER_STATUS_INVALID("2002", "exception.order_status_invalid", "订单状态无效"),
    ORDER_CANNOT_CANCEL("2003", "exception.order_cannot_cancel", "订单无法取消");
    
    // 实现接口方法...
}
```

### 添加自定义异常策略
```java
@Component
public class OrderExceptionStrategy implements ExceptionHandlerStrategy {
    
    @Override
    public boolean supports(Exception exception) {
        return exception instanceof OrderException;
    }
    
    @Override
    public ExceptionHandlerResult handle(Exception exception) {
        OrderException orderException = (OrderException) exception;
        
        // KISS原则：直接使用简化API，无需手动处理国际化
        return ExceptionHandlerResult.business(orderException.getCode());
    }
    
    @Override
    public int getPriority() {
        return 12; // 在业务异常之前处理
    }
}
```

## 📋 最佳实践

### ✅ 推荐做法

```java
// 1. 使用KISS原则的简化API（推荐！）
ExceptionUtils.throwBusiness(USER_NOT_FOUND);

// 2. 带参数的简化API
ExceptionUtils.throwBusiness(PARAM_OUT_OF_RANGE, "age", "18", "65");

// 3. 自定义异常策略中使用简化API
return ExceptionHandlerResult.business(exceptionCode);  // 自动国际化
return ExceptionHandlerResult.system(exceptionCode, args);  // 带参数

// 4. 使用断言简化代码
Assert.notNull(user, "user");
Assert.exists(order);

// 5. 条件异常一行搞定
ExceptionUtils.throwIf(condition, exceptionCode);
```

### ❌ 避免做法

```java
// 1. 不要直接throw new
throw new BusinessException(USER_NOT_FOUND);  // ❌

// 2. 不要暴露技术细节
throw new RuntimeException("Connection refused: localhost:3306");  // ❌

// 3. 不要使用魔法数字
Response.error(1001, "错误");  // ❌ 应该使用异常码枚举

// 4. 不要手动处理国际化（违反KISS原则）
String message = ExceptionUtils.getLocalizedMessage(exceptionCode);  // ❌
return ExceptionHandlerResult.business(code, message);  // ❌

// 应该直接使用：
return ExceptionHandlerResult.business(exceptionCode);  // ✅
```

## 🔧 调试技巧

### 日志查看
```bash
# 通过traceId查找相关日志
grep "abc123def456" application.log

# 查看特定异常类型
grep "BusinessException" application.log
```

### 开发环境调试
```java
// 在开发环境可以获取详细错误信息
if (log.isDebugEnabled()) {
    // 异常详细信息会记录在DEBUG日志中
}
```

## 🎯 团队协作规范

### 错误码分配
- 1000-1099：通用业务错误
- 1100-1199：参数验证错误  
- 1200-1299：用户相关错误
- 2000-2999：各业务模块自定义错误

### 命名规范
```java
// 错误码命名：模块_操作_结果
USER_LOGIN_FAILED("1203", "exception.user_login_failed", "用户登录失败")
ORDER_CANCEL_NOT_ALLOWED("2003", "exception.order_cancel_not_allowed", "订单无法取消")
```

### 消息规范
```java
// ✅ 用户友好的消息
"用户不存在"
"密码格式不正确，请输入6-20位字符"

// ❌ 技术性消息  
"User entity not found in database"
"Regex pattern validation failed"
```

## 🚀 从这里开始

1. **复制示例代码** - 直接使用上面的示例
2. **运行测试** - 验证异常处理是否正常工作
3. **查看日志** - 观察traceId和错误信息格式
4. **添加自定义异常码** - 根据业务需要扩展
5. **培训团队** - 让所有开发者统一使用这套规范

记住：这套异常体系的目标是让你**专注业务逻辑**，而不用担心异常处理的技术细节！