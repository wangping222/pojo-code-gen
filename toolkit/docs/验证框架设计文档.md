# 验证框架设计文档

## 📋 概述

本文档介绍toolkit模块中验证框架的设计思路、架构组成和使用方法。验证框架基于Java Bean Validation（JSR-303/JSR-380）标准，结合Spring Validation，提供了完整的数据验证解决方案。

## 🎯 设计目标

- **声明式验证** - 通过注解声明验证规则
- **分层验证** - 支持参数验证、Bean验证、业务规则验证
- **可扩展性** - 支持自定义验证器和验证规则
- **国际化** - 支持多语言验证消息
- **高性能** - 优化验证性能，支持缓存
- **易于测试** - 提供测试工具和模拟

## 🏗️ 架构设计

### 1. 验证层次结构

```
验证框架
├── 参数验证层 (Parameter Validation)
│   ├── 基础类型验证 (@NotNull, @NotBlank, @Size等)
│   ├── 格式验证 (@Pattern, @Email, @URL等)
│   └── 数值验证 (@Min, @Max, @Range等)
├── Bean验证层 (Bean Validation)
│   ├── 属性验证 (Field Validation)
│   ├── 跨字段验证 (Cross-field Validation)
│   └── 类级别验证 (Class-level Validation)
├── 业务规则验证层 (Business Rule Validation)
│   ├── 唯一性验证 (Uniqueness Validation)
│   ├── 依赖验证 (Dependency Validation)
│   └── 权限验证 (Permission Validation)
└── 自定义验证层 (Custom Validation)
    ├── 自定义注解 (Custom Annotations)
    ├── 自定义验证器 (Custom Validators)
    └── 复合验证器 (Composite Validators)
```

### 2. 核心组件

```
验证框架组件
├── validation/
│   ├── annotations/          # 验证注解
│   │   ├── basic/           # 基础验证注解
│   │   ├── business/        # 业务验证注解
│   │   └── custom/          # 自定义验证注解
│   ├── validators/          # 验证器实现
│   │   ├── basic/           # 基础验证器
│   │   ├── business/        # 业务验证器
│   │   └── custom/          # 自定义验证器
│   ├── groups/              # 验证组
│   ├── messages/            # 验证消息
│   ├── config/              # 验证配置
│   └── utils/               # 验证工具类
```

## 🚀 功能特性

### 1. 基础验证注解

#### 空值验证
```java
public class UserCreateRequest {
    @NotNull(message = "用户名不能为空")
    @NotBlank(message = "用户名不能为空白")
    private String username;
    
    @NotEmpty(message = "角色列表不能为空")
    private List<String> roles;
}
```

#### 长度和大小验证
```java
public class UserCreateRequest {
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20字符之间")
    private String username;
    
    @Length(min = 6, max = 50, message = "密码长度必须在6-50字符之间")
    private String password;
    
    @Range(min = 18, max = 100, message = "年龄必须在18-100之间")
    private Integer age;
}
```

#### 格式验证
```java
public class UserCreateRequest {
    @Email(message = "邮箱格式不正确")
    private String email;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String mobile;
    
    @URL(message = "网址格式不正确")
    private String website;
}
```

### 2. 自定义验证注解

#### 业务验证注解
```java
// 用户名唯一性验证
@UniqueUsername(message = "用户名已存在")
public class UserCreateRequest {
    private String username;
}

// 手机号验证
@ValidMobile(message = "手机号格式不正确")
public class UserCreateRequest {
    private String mobile;
}

// 身份证验证
@ValidIdCard(message = "身份证号格式不正确")
public class UserCreateRequest {
    private String idCard;
}

// 密码强度验证
@StrongPassword(message = "密码强度不足")
public class UserCreateRequest {
    private String password;
}
```

#### 跨字段验证
```java
@PasswordMatch(message = "两次输入的密码不一致")
public class UserCreateRequest {
    private String password;
    private String confirmPassword;
}

@DateRange(start = "startDate", end = "endDate", message = "结束日期必须大于开始日期")
public class TimeRangeQuery {
    private LocalDate startDate;
    private LocalDate endDate;
}
```

### 3. 验证组

#### 场景化验证
```java
public interface CreateGroup {}
public interface UpdateGroup {}

public class UserRequest {
    @NotNull(groups = {CreateGroup.class, UpdateGroup.class})
    private String username;
    
    @NotNull(groups = CreateGroup.class)
    private String password;
    
    @Null(groups = CreateGroup.class)
    @NotNull(groups = UpdateGroup.class)
    private Long id;
}

// 使用验证组
@PostMapping("/users")
public Response<User> createUser(@Validated(CreateGroup.class) @RequestBody UserRequest request) {
    // 创建用户逻辑
}

@PutMapping("/users/{id}")
public Response<User> updateUser(@Validated(UpdateGroup.class) @RequestBody UserRequest request) {
    // 更新用户逻辑
}
```

#### 验证序列
```java
@GroupSequence({BasicGroup.class, BusinessGroup.class})
public interface UserValidationSequence {}

public class UserRequest {
    @NotNull(groups = BasicGroup.class)
    private String username;
    
    @UniqueUsername(groups = BusinessGroup.class)
    private String username;
}
```

### 4. 条件验证

```java
@ConditionalValidation(
    condition = "type == 'EMAIL'",
    validations = {
        @ConditionalField(field = "email", constraints = @Email)
    }
)
@ConditionalValidation(
    condition = "type == 'SMS'", 
    validations = {
        @ConditionalField(field = "mobile", constraints = @ValidMobile)
    }
)
public class NotificationRequest {
    private String type;
    private String email;
    private String mobile;
}
```

## 🛠️ 自定义验证器

### 1. 简单验证器

```java
// 手机号验证注解
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = MobileValidator.class)
@Documented
public @interface ValidMobile {
    String message() default "手机号格式不正确";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// 手机号验证器
public class MobileValidator implements ConstraintValidator<ValidMobile, String> {
    
    private static final Pattern MOBILE_PATTERN = 
        Pattern.compile("^1[3-9]\\d{9}$");
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true; // 空值由@NotNull处理
        }
        return MOBILE_PATTERN.matcher(value).matches();
    }
}
```

### 2. 业务验证器

```java
// 用户名唯一性验证注解
@Target({ElementType.TYPE, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueUsernameValidator.class)
@Documented
public @interface UniqueUsername {
    String message() default "用户名已存在";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    
    String field() default "username";
    boolean ignoreCase() default false;
}

// 用户名唯一性验证器
@Component
public class UniqueUsernameValidator implements ConstraintValidator<UniqueUsername, Object> {
    
    @Autowired
    private UserRepository userRepository;
    
    private String fieldName;
    private boolean ignoreCase;
    
    @Override
    public void initialize(UniqueUsername annotation) {
        this.fieldName = annotation.field();
        this.ignoreCase = annotation.ignoreCase();
    }
    
    @Override
    public boolean isValid(Object value, ConstraintValidatorContext context) {
        if (value == null) {
            return true;
        }
        
        try {
            Field field = value.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            String username = (String) field.get(value);
            
            if (username == null) {
                return true;
            }
            
            return !userRepository.existsByUsername(username, ignoreCase);
            
        } catch (Exception e) {
            log.error("用户名唯一性验证失败", e);
            return false;
        }
    }
}
```

### 3. 跨字段验证器

```java
// 密码确认验证注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordMatchValidator.class)
@Documented
public @interface PasswordMatch {
    String message() default "两次输入的密码不一致";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    
    String password() default "password";
    String confirmPassword() default "confirmPassword";
}

// 密码确认验证器
public class PasswordMatchValidator implements ConstraintValidator<PasswordMatch, Object> {
    
    private String passwordField;
    private String confirmPasswordField;
    
    @Override
    public void initialize(PasswordMatch annotation) {
        this.passwordField = annotation.password();
        this.confirmPasswordField = annotation.confirmPassword();
    }
    
    @Override
    public boolean isValid(Object value, ConstraintValidatorContext context) {
        try {
            Field passwordField = value.getClass().getDeclaredField(this.passwordField);
            Field confirmPasswordField = value.getClass().getDeclaredField(this.confirmPasswordField);
            
            passwordField.setAccessible(true);
            confirmPasswordField.setAccessible(true);
            
            String password = (String) passwordField.get(value);
            String confirmPassword = (String) confirmPasswordField.get(value);
            
            return Objects.equals(password, confirmPassword);
            
        } catch (Exception e) {
            return false;
        }
    }
}
```

## 🔧 验证配置

### 1. Spring Boot 配置

```java
@Configuration
@EnableValidation
public class ValidationConfig {
    
    @Bean
    public Validator validator() {
        ValidatorFactory factory = Validation.byProvider(HibernateValidator.class)
                .configure()
                .messageInterpolator(messageInterpolator())
                .buildValidatorFactory();
        return factory.getValidator();
    }
    
    @Bean
    public MessageInterpolator messageInterpolator() {
        return new ResourceBundleMessageInterpolator(
                new PlatformResourceBundleLocator("ValidationMessages")
        );
    }
    
    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor(Validator validator) {
        MethodValidationPostProcessor processor = new MethodValidationPostProcessor();
        processor.setValidator(validator);
        return processor;
    }
}
```

### 2. 验证消息配置

```properties
# ValidationMessages.properties
validation.user.username.notblank=用户名不能为空
validation.user.username.size=用户名长度必须在{min}-{max}字符之间
validation.user.email.invalid=邮箱格式不正确
validation.user.mobile.invalid=手机号格式不正确
validation.user.password.weak=密码强度不足，至少包含8位字符，包括大小写字母、数字和特殊字符
validation.user.password.mismatch=两次输入的密码不一致
validation.user.username.exists=用户名 "{validatedValue}" 已存在

# ValidationMessages_zh_CN.properties
validation.user.username.notblank=用户名不能为空
validation.user.username.size=用户名长度必须在{min}-{max}字符之间

# ValidationMessages_en_US.properties
validation.user.username.notblank=Username cannot be blank
validation.user.username.size=Username length must be between {min}-{max} characters
```

### 3. 全局验证配置

```java
@Configuration
public class GlobalValidationConfig {
    
    @Bean
    public GlobalValidator globalValidator() {
        return GlobalValidator.builder()
                .failFast(false)                    // 不快速失败，收集所有错误
                .enableGroups(true)                 // 启用验证组
                .enableCrossFieldValidation(true)   // 启用跨字段验证
                .enableBusinessValidation(true)     // 启用业务验证
                .cacheValidationResults(true)       // 缓存验证结果
                .build();
    }
}
```

## 📖 使用示例

### 1. Controller 层验证

```java
@RestController
@RequestMapping("/api/users")
@Validated
public class UserController {
    
    // 请求体验证
    @PostMapping
    public Response<User> createUser(@Valid @RequestBody UserCreateRequest request) {
        User user = userService.createUser(request);
        return Response.success(user);
    }
    
    // 路径参数验证
    @GetMapping("/{id}")
    public Response<User> getUser(@PathVariable @Min(value = 1, message = "用户ID必须大于0") Long id) {
        User user = userService.getUser(id);
        return Response.success(user);
    }
    
    // 查询参数验证
    @GetMapping
    public Response<List<User>> queryUsers(
            @RequestParam @Size(min = 2, max = 20, message = "用户名长度必须在2-20字符之间") String username,
            @RequestParam @Valid UserQueryRequest query) {
        List<User> users = userService.queryUsers(username, query);
        return Response.success(users);
    }
    
    // 验证组使用
    @PostMapping("/register")
    public Response<User> register(@Validated(RegisterGroup.class) @RequestBody UserRequest request) {
        User user = userService.register(request);
        return Response.success(user);
    }
}
```

### 2. Service 层验证

```java
@Service
@Validated
public class UserService {
    
    // 方法参数验证
    @Validated(CreateGroup.class)
    public User createUser(@Valid UserCreateRequest request) {
        // 手动触发验证
        ValidationUtils.validate(request, CreateGroup.class);
        
        // 业务逻辑
        User user = userConverter.toEntity(request);
        return userRepository.save(user);
    }
    
    // 返回值验证
    @Validated
    public @Valid User updateUser(@Valid UserUpdateRequest request) {
        User existingUser = getUser(request.getId());
        userConverter.updateEntity(existingUser, request);
        return userRepository.save(existingUser);
    }
}
```

### 3. 自定义验证逻辑

```java
@Component
public class UserValidationService {
    
    public void validateUserCreation(UserCreateRequest request) {
        // 基础验证
        ValidationResult basicResult = ValidationUtils.validate(request);
        if (basicResult.hasErrors()) {
            throw new ValidationException(basicResult.getErrors());
        }
        
        // 业务规则验证
        validateBusinessRules(request);
    }
    
    private void validateBusinessRules(UserCreateRequest request) {
        // 用户名唯一性
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new BusinessException(I18nCommonExceptionCode.USER_ALREADY_EXISTS);
        }
        
        // 邮箱唯一性
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new BusinessException(I18nCommonExceptionCode.EMAIL_ALREADY_EXISTS);
        }
        
        // 密码强度验证
        if (!PasswordUtils.isStrongPassword(request.getPassword())) {
            throw new BusinessException(I18nCommonExceptionCode.PASSWORD_TOO_WEAK);
        }
    }
}
```

### 4. 批量验证

```java
@Service
public class BatchValidationService {
    
    public void validateUsers(List<UserCreateRequest> requests) {
        // 批量验证
        List<ValidationResult> results = ValidationUtils.validateBatch(requests);
        
        // 收集所有错误
        List<String> errors = results.stream()
                .filter(ValidationResult::hasErrors)
                .flatMap(result -> result.getErrors().stream())
                .map(FieldError::getDefaultMessage)
                .collect(Collectors.toList());
        
        if (!errors.isEmpty()) {
            throw new ValidationException("批量验证失败", errors);
        }
    }
    
    public void validateUsersWithGroups(List<UserCreateRequest> requests) {
        // 使用验证组进行批量验证
        ValidationUtils.validateBatch(requests, CreateGroup.class);
    }
}
```

## 🧪 测试支持

### 1. 验证测试工具

```java
@TestComponent
public class ValidationTestUtils {
    
    private static final Validator validator = Validation.buildDefaultValidatorFactory().getValidator();
    
    public static <T> Set<ConstraintViolation<T>> validate(T object) {
        return validator.validate(object);
    }
    
    public static <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {
        return validator.validate(object, groups);
    }
    
    public static <T> void assertValid(T object) {
        Set<ConstraintViolation<T>> violations = validate(object);
        if (!violations.isEmpty()) {
            String errors = violations.stream()
                    .map(ConstraintViolation::getMessage)
                    .collect(Collectors.joining(", "));
            throw new AssertionError("验证失败: " + errors);
        }
    }
    
    public static <T> void assertInvalid(T object, String expectedMessage) {
        Set<ConstraintViolation<T>> violations = validate(object);
        assertTrue("应该有验证错误", !violations.isEmpty());
        
        boolean found = violations.stream()
                .anyMatch(v -> v.getMessage().contains(expectedMessage));
        assertTrue("未找到期望的错误消息: " + expectedMessage, found);
    }
}
```

### 2. 验证单元测试

```java
@ExtendWith(MockitoExtension.class)
class UserCreateRequestValidationTest {
    
    @Test
    void testValidUser() {
        // given
        UserCreateRequest request = UserCreateRequest.builder()
                .username("testuser")
                .email("test@example.com")
                .password("StrongP@ss123")
                .age(25)
                .build();
        
        // when & then
        ValidationTestUtils.assertValid(request);
    }
    
    @Test
    void testInvalidUser_BlankUsername() {
        // given
        UserCreateRequest request = UserCreateRequest.builder()
                .username("")
                .email("test@example.com")
                .password("StrongP@ss123")
                .build();
        
        // when & then
        ValidationTestUtils.assertInvalid(request, "用户名不能为空");
    }
    
    @Test
    void testInvalidUser_InvalidEmail() {
        // given
        UserCreateRequest request = UserCreateRequest.builder()
                .username("testuser")
                .email("invalid-email")
                .password("StrongP@ss123")
                .build();
        
        // when & then
        ValidationTestUtils.assertInvalid(request, "邮箱格式不正确");
    }
    
    @Test
    void testValidationGroups() {
        // given
        UserRequest request = new UserRequest();
        request.setUsername("testuser");
        // 创建时不设置ID
        
        // when & then
        Set<ConstraintViolation<UserRequest>> violations = 
                ValidationTestUtils.validate(request, CreateGroup.class);
        
        assertTrue("创建时应该通过验证", violations.isEmpty());
    }
}
```

### 3. 自定义验证器测试

```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = TestConfig.class)
class UniqueUsernameValidatorTest {
    
    @MockBean
    private UserRepository userRepository;
    
    @Autowired
    private Validator validator;
    
    @Test
    void testUniqueUsername_Success() {
        // given
        when(userRepository.existsByUsername("newuser", false)).thenReturn(false);
        
        UserCreateRequest request = new UserCreateRequest();
        request.setUsername("newuser");
        
        // when
        Set<ConstraintViolation<UserCreateRequest>> violations = validator.validate(request);
        
        // then
        assertTrue("用户名唯一时应该通过验证", violations.isEmpty());
    }
    
    @Test
    void testUniqueUsername_Failure() {
        // given
        when(userRepository.existsByUsername("existinguser", false)).thenReturn(true);
        
        UserCreateRequest request = new UserCreateRequest();
        request.setUsername("existinguser");
        
        // when
        Set<ConstraintViolation<UserCreateRequest>> violations = validator.validate(request);
        
        // then
        assertFalse("用户名重复时应该验证失败", violations.isEmpty());
        assertTrue("应该包含用户名已存在的错误", 
                violations.stream().anyMatch(v -> v.getMessage().contains("用户名已存在")));
    }
}
```

## 🔧 高级特性

### 1. 条件验证

```java
@ConditionalValidation(
    condition = "#{type == 'ENTERPRISE'}",
    validations = {
        @ConditionalField(field = "companyName", constraints = @NotBlank),
        @ConditionalField(field = "taxNumber", constraints = @Pattern(regexp = "\\d{15}"))
    }
)
public class UserRegistrationRequest {
    private UserType type;
    private String companyName;
    private String taxNumber;
}
```

### 2. 动态验证规则

```java
@Component
public class DynamicValidationService {
    
    public void validateWithDynamicRules(Object object, String ruleSetName) {
        ValidationRuleSet ruleSet = ruleSetRepository.findByName(ruleSetName);
        
        for (ValidationRule rule : ruleSet.getRules()) {
            Object fieldValue = ReflectionUtils.getFieldValue(object, rule.getFieldName());
            
            if (!rule.validate(fieldValue)) {
                throw new ValidationException(rule.getErrorMessage());
            }
        }
    }
}
```

### 3. 性能优化

```java
@Configuration
public class ValidationPerformanceConfig {
    
    @Bean
    @ConditionalOnProperty(name = "validation.cache.enabled", havingValue = "true")
    public ValidationResultCache validationResultCache() {
        return CacheBuilder.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(1, TimeUnit.HOURS)
                .build();
    }
    
    @Bean
    public AsyncValidationService asyncValidationService() {
        return new AsyncValidationService(
                Executors.newFixedThreadPool(4)
        );
    }
}
```

## 📚 最佳实践

### 1. 验证注解使用原则

- **单一职责**: 每个验证注解只关注一个验证规则
- **组合使用**: 使用多个注解组合实现复杂验证
- **业务分离**: 基础验证和业务验证分离
- **性能优先**: 先执行简单验证，再执行复杂验证

### 2. 错误消息最佳实践

- **用户友好**: 错误消息应该易于理解
- **具体明确**: 明确指出错误的原因和解决方法
- **国际化**: 支持多语言错误消息
- **参数化**: 使用参数化消息模板

### 3. 验证组使用建议

- **场景分组**: 根据业务场景定义验证组
- **层次分组**: 使用验证序列控制验证顺序
- **默认组**: 合理使用默认验证组
- **组合验证**: 支持多组验证组合使用

### 4. 性能优化建议

- **缓存结果**: 缓存验证结果避免重复计算
- **异步验证**: 对于复杂的业务验证使用异步处理
- **批量验证**: 批量数据使用批量验证
- **索引优化**: 业务验证涉及的数据库查询要有合适的索引

## 📚 参考资料

- [Bean Validation 2.0 Specification (JSR 380)](https://beanvalidation.org/2.0/spec/)
- [Hibernate Validator Documentation](https://hibernate.org/validator/documentation/)
- [Spring Framework Validation](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation)
- [Spring Boot Validation](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.validation)