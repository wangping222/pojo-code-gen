# 安全组件设计文档

## 📋 概述

本文档介绍toolkit模块中安全组件的设计思路、架构组成和使用方法。安全组件基于Spring Security框架，提供认证、授权、加密、审计等完整的企业级安全解决方案。

## 🎯 设计目标

- **多层防护** - 提供认证、授权、加密、审计等多层安全防护
- **灵活配置** - 支持多种认证方式和授权策略
- **性能优化** - 高性能的安全检查和缓存机制
- **标准兼容** - 遵循OWASP安全标准和最佳实践
- **易于扩展** - 插件化设计，支持自定义安全组件

## 🏗️ 架构设计

### 1. 安全层次结构

```
安全框架
├── 认证层 (Authentication)
│   ├── 用户名密码认证
│   ├── JWT令牌认证  
│   ├── OAuth2认证
│   └── 多因素认证
├── 授权层 (Authorization)
│   ├── 角色权限控制
│   ├── 资源权限控制
│   ├── 数据权限控制
│   └── API权限控制
├── 加密层 (Encryption)
│   ├── 密码加密
│   ├── 数据加密
│   ├── 传输加密
│   └── 数字签名
└── 审计层 (Audit)
    ├── 操作日志
    ├── 安全事件
    ├── 登录记录
    └── 权限变更
```

### 2. 核心组件

```
security/
├── authentication/    # 认证组件
├── authorization/     # 授权组件  
├── encryption/        # 加密组件
├── audit/            # 审计组件
├── config/           # 安全配置
└── utils/            # 安全工具
```

## 🔐 认证组件

### 1. JWT认证配置

```java
@Configuration
@EnableWebSecurity
public class JwtSecurityConfig {
    
    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter(jwtTokenProvider());
    }
    
    @Bean
    public JwtTokenProvider jwtTokenProvider() {
        return JwtTokenProvider.builder()
                .secretKey(jwtProperties.getSecretKey())
                .tokenValidityInSeconds(jwtProperties.getTokenValidityInSeconds())
                .build();
    }
}
```

### 2. 多因素认证

```java
@Service
public class MultiFactorAuthService {
    
    public boolean verifyMFA(String userId, String code, MfaType type) {
        switch (type) {
            case SMS:
                return smsVerificationService.verify(userId, code);
            case EMAIL:
                return emailVerificationService.verify(userId, code);
            case TOTP:
                return totpService.verify(userId, code);
            default:
                return false;
        }
    }
}
```

## 🛡️ 授权组件

### 1. 基于注解的权限控制

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping
    public Response<User> createUser(@RequestBody UserCreateRequest request) {
        return userService.createUser(request);
    }
    
    @PreAuthorize("hasPermission(#id, 'USER', 'READ')")
    @GetMapping("/{id}")
    public Response<User> getUser(@PathVariable Long id) {
        return userService.getUser(id);
    }
}
```

### 2. 数据权限控制

```java
@Component
public class DataPermissionHandler {
    
    @DataPermission(type = "USER_DATA")
    public List<User> filterUserData(List<User> users, Authentication auth) {
        UserDetails userDetails = (UserDetails) auth.getPrincipal();
        
        if (hasRole(userDetails, "ADMIN")) {
            return users; // 管理员可查看所有数据
        }
        
        // 普通用户只能查看自己的数据
        return users.stream()
                .filter(user -> user.getId().equals(getCurrentUserId(userDetails)))
                .collect(Collectors.toList());
    }
}
```

## 🔒 加密组件

### 1. 密码加密工具

```java
@Component
public class PasswordEncryptionService {
    
    private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(12);
    
    public String encryptPassword(String rawPassword) {
        return passwordEncoder.encode(rawPassword);
    }
    
    public boolean matches(String rawPassword, String encodedPassword) {
        return passwordEncoder.matches(rawPassword, encodedPassword);
    }
}
```

### 2. 数据加密工具

```java
@Component
public class DataEncryptionService {
    
    @Value("${app.encryption.key}")
    private String encryptionKey;
    
    public String encrypt(String plainText) {
        return AESUtils.encrypt(plainText, encryptionKey);
    }
    
    public String decrypt(String encryptedText) {
        return AESUtils.decrypt(encryptedText, encryptionKey);
    }
}
```

## 📊 审计组件

### 1. 操作审计

```java
@Aspect
@Component
public class AuditAspect {
    
    @Around("@annotation(Auditable)")
    public Object audit(ProceedingJoinPoint joinPoint) throws Throwable {
        AuditEvent event = AuditEvent.builder()
                .userId(getCurrentUserId())
                .operation(joinPoint.getSignature().getName())
                .timestamp(LocalDateTime.now())
                .build();
        
        try {
            Object result = joinPoint.proceed();
            event.setStatus("SUCCESS");
            return result;
        } catch (Exception e) {
            event.setStatus("FAILURE");
            event.setErrorMessage(e.getMessage());
            throw e;
        } finally {
            auditService.saveAuditEvent(event);
        }
    }
}
```

## 📖 使用示例

### 1. 安全配置

```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf().disable()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .authorizeHttpRequests(auth -> auth
                    .requestMatchers("/api/auth/**").permitAll()
                    .requestMatchers("/api/admin/**").hasRole("ADMIN")
                    .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}
```

### 2. 用户认证

```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @PostMapping("/login")
    public Response<LoginResponse> login(@RequestBody LoginRequest request) {
        // 验证用户凭据
        Authentication auth = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        request.getUsername(), 
                        request.getPassword()
                )
        );
        
        // 生成JWT令牌
        String token = jwtTokenProvider.generateToken(auth);
        
        return Response.success(LoginResponse.builder()
                .accessToken(token)
                .tokenType("Bearer")
                .expiresIn(jwtProperties.getTokenValidityInSeconds())
                .build());
    }
}
```

## 📚 最佳实践

### 1. 密码安全
- 使用强密码策略
- 密码加盐哈希存储
- 定期密码过期提醒

### 2. 会话管理
- 使用JWT无状态认证
- 设置合理的令牌过期时间
- 支持令牌刷新机制

### 3. 权限控制
- 最小权限原则
- 角色和权限分离
- 动态权限控制

### 4. 数据保护
- 敏感数据加密存储
- 传输层TLS加密
- 数据脱敏处理

## 📚 参考资料

- [Spring Security Reference](https://spring.io/projects/spring-security)
- [OWASP Security Guidelines](https://owasp.org/)
- [JWT RFC 7519](https://tools.ietf.org/html/rfc7519)