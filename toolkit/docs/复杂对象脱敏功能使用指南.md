# 复杂对象脱敏功能使用指南

## 概述

审计组件完整支持对复杂对象内部属性的脱敏处理，解决了实际业务中方法参数通常是复杂类型而非简单字符串的问题。该功能通过注解和路径配置两种方式提供灵活的脱敏控制。

## 🎯 核心功能

### 1. 自动嵌套脱敏
通过 `@SensitiveField` 注解标记对象内部的敏感字段，系统会自动递归处理所有嵌套对象。

### 2. 字段路径脱敏
通过 `fieldPaths` 属性精确指定需要脱敏的字段路径，支持多层嵌套访问。

### 3. 混合脱敏策略
在同一个复杂对象中可以对不同字段使用不同的脱敏策略。

## 📝 使用方式

### 方式一：自动嵌套脱敏（推荐）

#### 1. 在模型类中标记敏感字段

```java
public class UserRegisterRequest {
    private String username;  // 普通字段，不脱敏
    
    @SensitiveField(strategy = MaskStrategy.FULL)
    private String password;  // 密码完全脱敏
    
    @SensitiveField(strategy = MaskStrategy.EMAIL)
    private String email;     // 邮箱脱敏
    
    @SensitiveField(strategy = MaskStrategy.PHONE)
    private String phone;     // 手机号脱敏
    
    @SensitiveField(enableNested = true)
    private UserProfile profile;  // 嵌套对象，递归处理
}

public class UserProfile {
    @SensitiveField(strategy = MaskStrategy.ID_CARD)
    private String idCard;    // 身份证脱敏
    
    @SensitiveField(strategy = MaskStrategy.BANK_CARD)
    private String bankCard;  // 银行卡脱敏
    
    private String gender;    // 普通字段，不脱敏
    
    @SensitiveField(enableNested = true)
    private Address address;  // 继续嵌套
}
```

#### 2. 在方法上使用 `@SensitiveParam`

```java
@Auditable(operation = "用户注册")
public String registerUser(
    @SensitiveParam(
        autoNested = true,  // 启用自动嵌套脱敏
        description = "用户注册请求"
    ) UserRegisterRequest request) {
    // 业务逻辑
    return "注册成功";
}
```

### 方式二：字段路径脱敏

当你需要精确控制哪些字段进行脱敏时，可以使用字段路径方式：

```java
@Auditable(operation = "更新用户档案")
public void updateProfile(
    @SensitiveParam(
        fieldPaths = {
            "profile.realName",              // 档案中的真实姓名
            "profile.idCard",                // 档案中的身份证号
            "profile.address.detailAddress", // 嵌套对象中的详细地址
            "emergencyContact.contactPhone"  // 紧急联系人电话
        },
        strategy = MaskStrategy.DEFAULT,
        autoNested = false,  // 禁用自动脱敏，只处理指定字段
        description = "用户更新请求"
    ) UserRegisterRequest updateRequest) {
    // 业务逻辑
}
```

### 方式三：混合脱敏策略

在同一个对象中对不同字段使用不同策略：

```java
@Auditable(operation = "实名认证")
public boolean performKYC(
    @SensitiveParam(
        fieldPaths = {"profile.bankCardNumber"},  // 只脱敏银行卡号
        strategy = MaskStrategy.BANK_CARD,        // 使用银行卡脱敏策略
        autoNested = false,                       // 禁用自动脱敏
        description = "KYC验证请求"
    ) UserRegisterRequest kycRequest,
    
    @SensitiveParam(strategy = MaskStrategy.FULL)
    String verificationPassword) {  // 验证密码完全脱敏
    // 业务逻辑
    return true;
}
```

## 🔧 脱敏策略

支持的脱敏策略包括：

| 策略 | 说明 | 适用字段 | 示例 |
|------|------|----------|------|
| `DEFAULT` | 保留前2后2位 | 通用敏感信息 | `张三` → `张*三`，`abcdefg` → `ab***fg` |
| `FULL` | 完全脱敏 | 密码、密钥 | `password123` → `****` |
| `EMAIL` | 邮箱脱敏 | 邮箱地址 | `user@example.com` → `u***@example.com` |
| `PHONE` | 手机号脱敏 | 手机号码 | `13812345678` → `138****5678` |
| `BANK_CARD` | 银行卡脱敏 | 银行卡号 | `6225881234567890` → `**** **** **** 7890` |
| `ID_CARD` | 身份证脱敏 | 身份证号 | `440301199001011234` → `4403**********1234` |
| `CUSTOM` | 自定义脱敏 | 特殊场景 | 基于SpEL表达式自定义 |

### 自定义脱敏示例

```java
@SensitiveField(
    strategy = MaskStrategy.CUSTOM,
    customExpression = "#value.length() > 20 ? #value.substring(0, 5) + '***[已脱敏]***' + #value.substring(#value.length()-5) : '***[已脱敏]***'",
    description = "个人简介"
)
private String biography;
```

## 📊 实际脱敏效果

### 原始数据
```json
{
    "username": "zhangsan123",
    "password": "MySecretPassword123!",
    "email": "zhangsan@example.com",
    "phone": "13712345678",
    "profile": {
        "realName": "张三",
        "idCard": "440301199001011234",
        "bankCardNumber": "6225881234567890123",
        "address": {
            "detailAddress": "科技园南区深南大道9999号科技大厦A座1001室",
            "longitude": 113.934782,
            "latitude": 22.547234
        }
    },
    "emergencyContact": {
        "contactName": "李四",
        "contactPhone": "13987654321",
        "contactEmail": "lisi@example.com"
    }
}
```

### 脱敏后数据（使用自动嵌套脱敏）
```json
{
    "username": "zhangsan123",
    "password": "****",
    "email": "z***@example.com",
    "phone": "137****5678",
    "profile": {
        "realName": "张*三",
        "idCard": "4403**********1234",
        "bankCardNumber": "**** **** **** 0123",
        "address": {
            "detailAddress": "科技****1室",
            "longitude": "113.934***",
            "latitude": "22.547***"
        }
    },
    "emergencyContact": {
        "contactName": "李*四",
        "contactPhone": "139****4321",
        "contactEmail": "l***@example.com"
    }
}
```

## 🚀 性能优化

### 1. 类字段缓存
系统会缓存已分析的类结构，避免重复反射：

```java
// 缓存已分析的类结构，避免重复反射
private static final Map<Class<?>, List<SensitiveFieldInfo>> CLASS_FIELD_CACHE = new ConcurrentHashMap<>();
```

### 2. 智能类型检测
只对复杂对象进行JSON序列化处理，简单类型直接脱敏：

```java
// 如果是基本类型或字符串，直接脱敏
if (isSimpleType(data.getClass())) {
    return DataMaskingUtils.maskData(data, strategy, customExpression);
}
```

### 3. 异步处理
脱敏处理在异步线程中执行，不影响主业务性能：

```java
@Auditable(
    operation = "批量处理",
    async = true,  // 异步执行审计和脱敏
    includeParameters = false  // 大批量数据不记录参数
)
```

## 🎛️ 配置选项

### 1. 全局开关
```java
@Auditable(
    enableParamAnnotations = true,  // 启用参数注解扫描（默认true）
    includeParameters = true        // 是否记录参数（默认true）
)
```

### 2. 字段级别控制
```java
@SensitiveField(
    strategy = MaskStrategy.DEFAULT,
    enableNested = true,    // 是否启用嵌套脱敏（默认true）
    description = "字段描述"
)
```

### 3. 参数级别控制
```java
@SensitiveParam(
    fieldPaths = {...},     // 指定字段路径
    autoNested = true,      // 自动嵌套脱敏（默认true）
    strategy = MaskStrategy.DEFAULT
)
```

## ⚠️ 注意事项

### 1. 注解优先级
当同时使用多种配置方式时，优先级为：
1. **参数注解** (`@SensitiveParam`)
2. **字段注解** (`@SensitiveField`)
3. **参数名称配置** (`sensitiveParamNames`)

### 2. 序列化兼容性
- 系统使用Jackson进行JSON序列化
- 支持循环引用检测
- 兼容常见的序列化注解

### 3. 内存和性能
- 大对象建议使用 `@IgnoreParam` 跳过记录
- 复杂脱敏逻辑建议缓存结果
- 异步模式下注意线程安全

## 🧪 测试验证

### 单元测试示例
```java
@Test
public void testComplexObjectMasking() {
    // 创建测试数据
    UserRegisterRequest request = createSampleUserRequest();
    
    // 执行带脱敏的方法
    String result = auditService.registerUserWithComplexObject(request);
    
    // 验证审计日志中的脱敏效果
    // 可以通过AuditEvent验证脱敏是否正确
}
```

### 集成测试
```java
@SpringBootTest
public class ComplexObjectMaskingIntegrationTest {
    
    @Autowired
    private AuditExample auditExample;
    
    @Test
    public void testNestedObjectMasking() {
        UserRegisterRequest request = auditExample.createSampleUserRequest();
        auditExample.registerUserWithComplexObject(request);
        
        // 验证审计事件记录
        // 检查敏感数据是否正确脱敏
    }
}
```

## 📚 最佳实践

### 1. 注解设计原则
- **明确性**：清楚标记哪些字段是敏感的
- **一致性**：在项目中统一使用相同的脱敏策略
- **文档化**：为敏感字段添加描述信息

### 2. 脱敏策略选择
- **密码类**：使用 `FULL` 策略
- **联系方式**：使用对应的专用策略（`EMAIL`、`PHONE`）
- **身份信息**：使用 `ID_CARD`、`BANK_CARD` 策略
- **通用敏感信息**：使用 `DEFAULT` 策略

### 3. 性能优化建议
- **大对象处理**：对于超大对象，考虑使用 `@IgnoreParam`
- **异步审计**：重要但非实时的审计使用异步模式
- **缓存利用**：充分利用系统的类结构缓存机制

---

通过以上功能，审计组件可以完美支持复杂业务对象的敏感数据脱敏，既保证了审计的完整性，又保护了用户的隐私安全。