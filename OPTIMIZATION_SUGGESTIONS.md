# POJO Code Generator 优化建议文档

本文档旨在为 POJO Code Generator 项目提供一系列优化建议，以提高其代码质量、可维护性、灵-活性和可扩展性。

## 1. 通过抽象基类减少代码重复

**问题现状：**

在 `com.example.generator.generators` 包下的所有生成器类（如 `DtoGenerator`, `RequestGenerator` 等）中，存在大量重复的样板代码。每个类都独立实现了构建类、添加注解、遍历字段等通用逻辑，导致代码冗余且难以维护。

**优化建议：**

创建一个抽象基类 `AbstractBaseGenerator`，将所有生成器共享的逻辑封装起来。

**示例实现：**

```java
// src/main/java/com/example/generator/generators/AbstractBaseGenerator.java
package com.example.generator.generators;

import com.example.generator.CodeGenerator;
import com.example.generator.model.PackageConfig;
import com.example.generator.model.PojoInfo;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public abstract class AbstractBaseGenerator implements CodeGenerator {

    protected final PackageConfig packageConfig;

    @Override
    public JavaFile generate(PojoInfo pojoInfo) {
        // 1. 创建类/接口构建器
        TypeSpec.Builder specBuilder = createTypeSpecBuilder(pojoInfo);

        // 2. 添加通用注解和修饰符
        addCommonAnnotations(specBuilder);

        // 3. 添加字段
        addFields(specBuilder, pojoInfo);

        // 4. 添加特有的方法或配置（由子类实现）
        addSpecificParts(specBuilder, pojoInfo);

        // 5. 构建并返回 JavaFile
        return JavaFile.builder(getTargetPackage(), specBuilder.build())
                .addFileComment("Generated by POJO Code Generator. Do not edit!")
                .build();
    }

    protected abstract TypeSpec.Builder createTypeSpecBuilder(PojoInfo pojoInfo);

    protected abstract String getTargetPackage();

    protected void addCommonAnnotations(TypeSpec.Builder specBuilder) {
        // 默认实现，子类可覆盖
    }

    protected void addFields(TypeSpec.Builder specBuilder, PojoInfo pojoInfo) {
        // 默认实现：遍历并添加所有字段
    }

    protected void addSpecificParts(TypeSpec.Builder specBuilder, PojoInfo pojoInfo) {
        // 钩子方法，留给子类实现特定逻辑
    }
}
```

具体的生成器（如 `DtoGenerator`）只需继承 `AbstractBaseGenerator` 并实现其特定的逻辑即可，从而大大简化代码。

## 2. 自动化 `PojoInfo` 创建

**问题现状：**

使用者必须在 `main` 方法中手动编写 Java 代码来实例化和填充 `PojoInfo` 对象。这个过程对于字段繁多的实体类来说非常繁琐、易错，且造成了信息冗余。

**优化建议：**

增强 `PojoParser` 的功能，使其能够自动从已有的 Java 实体类源文件（`.java`）或编译后的类文件（`.class`）中解析出所需信息，并自动创建 `PojoInfo` 对象。

**实现方案：**

1.  **解析 `.java` 源文件（推荐）**：
    *   利用 `com.github.javaparser` 库来解析指定的实体类源文件。
    *   从解析出的抽象语法树（AST）中提取类名、包名、类注释以及每个字段的名称、类型和注释。
    *   用提取到的信息自动填充并返回一个 `PojoInfo` 实例。

2.  **使用 Java 反射机制**：
    *   如果实体类已经被编译并位于项目的 classpath 下，可以通过反射（`Class.forName()`）加载该类。
    *   通过反射 API 获取类名、字段、注解等信息来构建 `PojoInfo`。

## 3. 使用外部化配置文件

**问题现状：**

所有配置（如输出目录、要生成的代码类型等）都硬编码在 `example` 模块的 `main` 方法中。这使得配置的修改非常不便，每次都需要更改源代码并重新编译。

**优化建议：**

将所有配置项移至项目根目录下的一个外部配置文件中（如 `generator-config.yaml`），使项目由代码驱动转变为配置驱动。

**示例 `generator-config.yaml`:**

```yaml
# 生成代码的全局配置
outputDirectory: "src/main/generated-java"
basePackage: "com.example.myapp"

# 要进行代码生成的实体类列表
entities:
  - name: "User"
    sourceFile: "C:/path/to/your/project/entity/User.java" # 使用 PojoParser 解析
    classComment: "用户实体"
  - name: "Product"
    sourceFile: "C:/path/to/your/project/entity/Product.java"
    classComment: "产品实体"

# 要为每个实体生成的代码类型
generators:
  - "Dto"
  - "Request"
  - "Response"
  - "Service"
  - "ServiceImpl"
  - "Repository"
  - "Mapstruct"
```

应用程序启动时，应首先解析此 YAML 文件，然后根据其中的配置来驱动整个代码生成流程。

## 4. 提高可扩展性

**问题现状：**

每当添加一个新的生成器实现时，都需要修改 `CodeGeneratorMain` 的代码来手动实例化并调用它，这违反了“对扩展开放，对修改关闭”的设计原则。

**优化建议：**

利用 Java 的 `ServiceLoader` 机制实现生成器的自动发现和加载。

**实现步骤：**

1.  **创建服务注册文件**：
    在 `generator-core` 模块的 `src/main/resources/META-INF/services/` 目录下，创建一个名为 `com.example.generator.CodeGenerator` 的文件。

2.  **注册实现类**：
    在该文件中，列出所有 `CodeGenerator` 接口的具体实现类的全限定名，每行一个。
    ```
    com.example.generator.generators.DtoGenerator
    com.example.generator.generators.RequestGenerator
    com.example.generator.generators.ResponseGenerator
    # ... 其他生成器
    ```

3.  **动态加载生成器**：
    在主程序中，使用 `ServiceLoader` 来加载所有已注册的 `CodeGenerator` 服务。
    ```java
    import java.util.ServiceLoader;

    public class Main {
        public static void main(String[] args) {
            // 加载配置文件 (见建议3)
            // ...

            ServiceLoader<CodeGenerator> loader = ServiceLoader.load(CodeGenerator.class);

            // 根据配置文件中启用的 generators，筛选并执行
            for (CodeGenerator generator : loader) {
                String generatorName = generator.getClass().getSimpleName().replace("Generator", "");
                if (config.getGenerators().contains(generatorName)) {
                    // ... 执行生成逻辑
                }
            }
        }
    }
    ```

通过这种方式，未来如果需要添加新的生成器（例如 `VoGenerator`），只需实现 `CodeGenerator` 接口，并将其全限定名添加到服务注册文件中即可，无需修改任何现有的调用代码。
